#!/usr/bin/env python
# coding: utf-8

# # Библиотека `NumPy`: часть 1
# 
# *Алла Тамбовцева*
# 
# ## Домашнее задание 
# 
# ### Описание домашнего задания и формат сдачи
# 
# В домашнем задании необходимо решить предложенные задачи по программированию – вписать свой код в ячейки после условий задач вместо комментария `### YOUR CODE HERE ###` в файле *homework-numpy1.ipynb* и сохранить изменения, используя опцию *Save and Checkpoint* из вкладки меню *File* или кнопку *Save and Checkpoint* на панели инструментов. Итоговый файл в формате `.ipynb` (файл Jupyter Notebook) необходимо загрузить в личный кабинет обучающей онлайн платформы Skillbox (https://go.skillbox.ru/) и отправить на проверку.

# Дан массив, содержащий баллы слушателей курса по английскому языку за вступительный экзамен. Слушатели распределены по 15 группам по 10 человек.

# ### Задание 1
# 
# Посчитать, сколько слушателей получили 0 за вступительный экзамен.

# In[3]:


import numpy as np
scores = np.array([[20, 40, 56, 80, 0, 5, 25, 27, 74, 1],
         [0, 98, 67, 100, 8, 56, 34, 82, 100, 7],
         [78, 54, 23, 79, 100, 0, 0, 42, 95, 83],
         [51, 50, 47, 23, 100, 94, 25, 48, 38, 77],
         [90, 87, 41, 89, 52, 0, 5, 17, 28, 99],
         [32, 18, 21, 18, 29, 31, 48, 62, 76, 22],
         [6, 0, 65, 78, 43, 22, 38, 88, 94, 100],
         [77, 28, 39, 41, 0, 81, 45, 54, 98, 12],
         [66, 0, 88, 0, 44, 0, 55, 100, 12, 11],
         [17, 70, 86, 96, 56, 23, 32, 49, 70, 80],
         [20, 24, 76, 50, 29, 40, 3, 2, 5, 11],
         [33, 63, 28, 40, 51, 100, 98, 87, 22, 30],
         [16, 54, 78, 12, 25, 35, 10, 19, 67, 0],
         [100, 88, 24, 33, 47, 56, 62, 34, 77, 53],
         [50, 89, 70, 72, 56, 29, 15, 20, 0, 0]])


# In[6]:


scores[scores == 0].size


# ### Задание 2
# 
# Посчитать, сколько слушателей получили балл выше 50.

# In[7]:


scores[scores > 50].size


# ### Задание 3
# 
# Посчитать, сколько человек получили балл не ниже 50, но не выше 70.

# In[9]:


scores[(scores >= 50) & (scores < 70)].size


# ### Задание 4
# 
# Определить, в какой группе средний балл за вступительный экзамен выше.

# In[17]:


scores.mean(axis = 1).max()


# ### Задание 5
# 
# Сохранить баллы слушателей выше 0 в массив `nonzero`. 

# In[19]:


nonzero = scores[scores != 0]
nonzero


# ### Задание 6
# 
# Используя массив `nonzero`, определить минимальный балл за вступительный балл по всем группам.

# In[20]:


nonzero.min()


# ### Задание 7
# 
# Выбрать из массива `nonzero` только те значения, которые соответствуют продвинутому уровню знания языка – баллу за экзамен выше 80. Сохранить полученный результат в массив `advanced`. В заданиях 8-10 нужно работать с массивом `advanced`.

# In[21]:


advanced = nonzero[nonzero > 80]
advanced


# ### Задание 8
# 
# Определить размерность массива `advanced`.

# In[26]:


advanced.shape


# ### Задание 9
# 
# Определить форму массива `advanced`.

# In[28]:


advanced.ndim


# ### Задание 10
# 
# Определить общее число элементов в массиве `advanced`.

# In[29]:


advanced.size


# ### Задание 11
# 
# На основе исходного массива `scores` создать булев массив `sto`, где `True` соответствует баллам за экзамен, равным 100, а `False` – всем остальным баллам. 

# In[31]:


sto = scores == 100
sto


# ### Задание 12
# 
# На основе исходного массива `scores` вывести на экран оценки слушателей первых семи групп (включительно, должны быть 7 списков оценок).

# In[35]:


scores[0:7]


# .<br> .<br> .<br> .<br> .<br> .<br> .<br> .<br> .<br> .<br> .<br> .<br> .<br> .<br> .<br> .<br> .<br> .<br> 
# # Дополнительное (необязательное) задание.
# <br>
# 

# В заданиях 1-2 необходимо работать с массивом `A`:

# In[37]:


A = np.array([[2, 9, 8, 0],
             [8, 7, 5, 6], 
             [3, 1, 0, 2], 
             [6, 5, 6, 8],
             [1, 0, 0, 4]])


# ### Задание 1
# 
# Транспонировать массив `A`, не используя встроенных методов `NumPy`. Сохранить полученный массив в переменную `A_tr`. Допустимо использовать циклы и условные конструкции (при необходимости).
# 
# **Напоминание:** транспонирование – операция замены строк и столбцов местами. Пример:
# 
# До транспонирования:
# 
#         [[2, 5, 0], 
#         [7, 8, 1]]
# 
# После транспонирования:
# 
#         [[2, 7],
#         [5, 8],
#         [0, 1]]
# 
# **Подсказка:** можно почитать про цикл *for* на [pythontutor.ru](https://pythontutor.ru/lessons/for_loop/). На самом деле, если вспомнить про выбор элементов в массиве `NumPy`, то одного цикла будет достаточно, условные конструкции не понадобятся.

# In[40]:


rows, cols = A.shape
A_tr = np.empty((cols, rows), dtype=A.dtype)
for i in range(rows):
    for j in range(cols):
        A_tr[j][i] = A[i][j]
A_tr


# ### Задание 2
# 
# Сравнить результаты: проверить равенство полученного выше массива `A_tr` и массива, который получается транспонированием массива `A` с помощью метода `.T`. 
# 
# **Подсказка:** для сравнения массивов целиком, не поэлементно, можно использовать [функцию](https://docs.scipy.org/doc/numpy/reference/generated/numpy.array_equal.html) `array_equal()`.

# In[43]:


np.array_equal(A_tr, A.T)


# ### Задание 3
# 
# Студент N подрабатывает репетитором по математике и ведёт занятия разных типов: готовит к ЕГЭ, к олимпиадам, «подтягивает» математику у школьников младших классов. 
# 
# В массиве `classes` хранится число проведённых уроков за пять рабочих дней, в массиве `prices` — стоимость одного урока (считаем, что студент за день проводит занятия одного типа, одинаковые по стоимости).
# 
# Определить доход студента за неделю, используя [метод](https://docs.scipy.org/doc/numpy/reference/generated/numpy.dot.html) `.dot()` для нахождения [скалярного произведения](https://ru.wikipedia.org/wiki/%D0%A1%D0%BA%D0%B0%D0%BB%D1%8F%D1%80%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5). 

# In[45]:


classes = np.array([3, 3, 2, 0, 2])
prices = np.array([1500, 1500, 2500, 1000, 1000])


# In[46]:


income = classes.dot(prices)
income


# ### Задание 4
# 
# По результатам работы с данными по оценкам за эссе студентов, поставленным двумя разными экспертами, были созданы два булевых массива `expert1` и `expert2`, в которых значение `True` означает оценку «удовлетворительно» и выше, а значение `False` – неудовлетворительно. Всего было оценено 15 эссе, по 5 эссе на каждую из трёх тем.

# In[47]:


expert1 = np.array([[True, False, False, True, True],
                   [False, True, False, False, True],
                   [True, True, True, False, False]])
expert2 = np.array([[True, False, False, False, True],
                   [False, False, False, False, False],
                   [True, False, True, False, False]])


# In[54]:


agreed_grades = expert1 & expert2
agreed_grades[agreed_grades == True].size


# Определить, используя различные логические операторы (`|`, `&`, и проч.) и вспомогательные методы/функции, сколько студентов получат зачёт, если известно, что для этого необходимо получить оценку не ниже удовлетворительной у обоих экспертов.

# ### Задание 5
# 
# Дан массив `essay` с итоговыми оценками студентов за эссе из задачи 4:

# In[55]:


# pass - сдал
# not pass - не сдал

essay = np.array([["pass", "not pass", "not pass", "not pass", "pass"],
        ["not pass", "not pass", "not pass", "not pass", "not pass"],
        ["pass", "not pass", "pass", "not pass", "not pass"]])


# Проверить ответ в предыдущей задаче, используя массив `essay`. Решение должно быть представлено в виде кода, не в виде выводов в результате явного подсчёта элементов.

# In[60]:


rez = np.empty(3, 5)
for i in range(agreed_grades.size):
    for j in range(essay.size):
        rez[i] = [agreed_grades[i], essay[j]]
        
rez


# ### Задание 6
# 
# Используя массивы `expert1` и `expert2` из задачи 4, определить согласованность двух экспертов, используя меру близости Жаккара, которая вычисляется следующим образом:
# 
# $$
# J(A, B) = \frac{|A \cap B|}{|A| + |B| - |A \cap B|}
# ,$$ 
# 
# где $A$ – первое множество, $B$ – второе множество, $A \cap B$ – пересечение множеств, т.е. их общие элементы. Запись $|A|$ означает «количество элементов в множестве». 
# 
# В качестве множеств $A$ и $B$ в данной задаче выступают множества (группы) студентов, которые получили зачёт у первого и второго экспертов.

# In[62]:


intersection = expert1 & expert2
num_students_expert1 = np.sum(expert1, axis=1)
num_students_expert2 = np.sum(expert2, axis=1)
jaccard_similarity = intersection.sum(axis=1) / (num_students_expert1 + num_students_expert2 - intersection.sum(axis=1))
jaccard_similarity


# In[ ]:




